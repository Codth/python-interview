# 数据结构    

# 一. 排序    
排序是算法的入门知识，其思想可以用于很多算法中，而且因为排序算法实现代码比较少，应用较为广泛，所以在程序员面试笔试中，求职者经常会被问及
排序算法及其相关的问题。虽然排序算法名目繁多，各不相同，但是万变不离其宗，只要熟悉了算法的思想，灵活运用它们也并非难事。     
一般在笔试中最常考到的排序算法是快速排序和归并排序，而插入排序、冒泡排序、堆排序、基数排序、桶排序等算法也经常被提及。而排序算法的考察形式往往
也比较常见，就是面试官要求求职者现场写代码，同时也会要求求职者分析各类排序算法的优劣、使用场景、时间复杂度以及空间复杂度等，所以，求职者熟练
掌握各类排序算法思想及特点是非常必要的。     

## 1. 选择排序     
选择排序是一种简单直观的排序算法，它的基本原理是：对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录与第一个记录进行交换；接着对
不包括第一个记录以外的其他记录进行第二轮比较，得到最新小的记录并与第二个记录进行位置交换；重复该过程，直到进行比较的记录只有一个时为止。      
代码实现：      
```python    
import random
mess = (random.randint(1, 1000) for i in range(10))


# 基础版
def select_sort(seq):
    """可以对python中的可迭代对象进行排序"""
    temp_list = list(seq)
    length = len(temp_list)
    for i in range(length-1):
        minimum_index = i
        for j in range(i+1, length):
            if temp_list[j] < temp_list[minimum_index]:
                minimum_index = j
        if i != minimum_index:
            temp_list[i], temp_list[minimum_index] = temp_list[minimum_index], temp_list[i]
    return temp_list


# 进阶版
def select_sort1(seq):
    temp_list = list(seq)
    length = len(temp_list)
    for i in range(length//2):
        minimum_index = i
        maximum_index = -i - 1
        for j in range(i+1, length-i-1):
            if temp_list[j] < temp_list[minimum_index]:
                minimum_index = j
            if temp_list[-j-1] > temp_list[maximum_index]:
                maximum_index = -j - 1
        if temp_list[minimum_index] == temp_list[maximum_index]:
            break
        if maximum_index != -i-1:
            temp_list[maximum_index], temp_list[-i-1] = temp_list[-i-1], temp_list[maximum_index]
            if minimum_index == -i-1 or -i-1 == minimum_index - length:
                minimum_index = maximum_index + length
        if minimum_index != i:
            temp_list[i], temp_list[minimum_index] = temp_list[minimum_index], temp_list[i]
    return temp_list


if __name__ == '__main__':
    print(select_sort1(mess))
```     
选择排序是一种不稳定的排序方法，其中基础版最好、最坏的平均情况下时间复杂度都是O(n<sup>2</sup>)，进阶版最好情况下时间复杂度是O(n)。


## 2. 插入排序    
对于给定的一组记录，初始时假设第一个记录自成一个有序序列，其余的记录为无序序列；接着从第二个记录开始，按照记录的大小依次将当前处理的记录插入
到其之前的有序序列中，直到最后一个记录插入到有序序列中为止。       
```python    
import random
mess = (random.randint(1, 1000) for i in range(10))


def insert_sort(seq):
    tem_list = [None] + list(seq)  # [None, 3, 2, 6, 1]
    for i in range(2, len(tem_list)):
        tem_list[0] = tem_list[i]
        while tem_list[0] < tem_list[i-1]:
            tem_list[i] = tem_list[i-1]
            i -= 1
        tem_list[i] = tem_list[0]
    return tem_list[1:]


if __name__ == '__main__':
    print(insert_sort(mess))
```     
插入排序是一种稳定的排序方法，最好情况下的时间复杂度是O(n)，最坏情况下的时间复杂度为O(n<sup>2</sup>)，平均情况下的时间复杂度为O(n<sup>2</sup>)；空间复杂度为O(1)。    


## 3. 冒泡排序   
冒泡排序顾名思义就是整个过程就像冒气泡一样往上升，单向冒泡排序的基本思想是（假设由小到大排序）：对于给定的n个记录，从第一个记录开始依次对相邻
的两个记录进行比较，当前面的记录大于后面的记录时，交换其位置，进行一轮比较和换位后，n个记录中的最大记录将位于第n位；然后对前n-1个记录进行第
二轮比较；重复该过程直到进行比较的记录只剩下一个时为止。    
代码：    
```python    
import random
mess = (random.randint(1, 1000) for i in range(10))


def bubble_sort(seq):
    tem_list = list(seq)
    length = len(tem_list)

    for i in range(length-1):
        flag = True
        for j in range(length-i-1):
            if tem_list[j] > tem_list[j+1]:
                flag = False
                tem_list[j], tem_list[j+1] = tem_list[j+1], tem_list[j]
        if flag:
            break
    return tem_list


if __name__ == '__main__':
    print(bubble_sort(mess))
```    
冒泡排序是一种稳定的排序方法，最好的情况下的时间复杂度为O(n)，最坏情况下时间复杂度为O(n<sup>2</sup>)，平均情况下的时间复杂度为O(n<sup>2</sup>)；空间复杂度(1).      

## 4. 归并排序   
归并排序是利用递归与分治技术将数据序列划分成越来越小的半子表，再对半子表排序，最后再用递归步骤将排好序的半子表合并成为越来越大的序列，其中`归`代表递归，即递归地将数组折半地分离为单个数组。     
代码:    
```python    
import random
mess = [random.randint(1, 1000) for i in range(10)]


def merge_sort(seq):
    if len(seq) <= 1:
        return seq
    else:
        mid = len(seq) // 2
        left_half = merge_sort(seq[:mid])
        right_half = merge_sort(seq[mid:])

        new_seq = merge(left_half, right_half)
        return new_seq


def merge(seq_a, seq_b):
    length_a, length_b = len(seq_a), len(seq_b)
    a = b = 0
    new_seq = list()

    while a < length_a and b < length_b:
        if seq_a[a] < seq_b[b]:
            new_seq.append(seq_a[a])
            a += 1
        else:
            new_seq.append(seq_b[b])
            b += 1

    if a < length_a:
        new_seq.extend(seq_a[a:])
    elif b < length_b:
        new_seq.extend(seq_b[b:])
    return new_seq


if __name__ == '__main__':
    print(merge_sort(mess))
```   
二路归并排序的过程需要进行logn次，每一趟归并排序的操作就是将两个有序子序列进行归并，而每一对有序子序列归并时，记录的比较次数均小于等于记录的移动次数，记录移动的次数均等于记录的个数n，即每趟归并的时间复杂度是O(n)，因此二路归并排序在最好、最坏和平均情况的时间复杂度为O(nlogn)，而且是一种稳定的排序方法，空间复杂度为O(1)。
