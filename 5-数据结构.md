# 数据结构    

# 一. 排序    
排序是算法的入门知识，其思想可以用于很多算法中，而且因为排序算法实现代码比较少，应用较为广泛，所以在程序员面试笔试中，求职者经常会被问及
排序算法及其相关的问题。虽然排序算法名目繁多，各不相同，但是万变不离其宗，只要熟悉了算法的思想，灵活运用它们也并非难事。     
一般在笔试中最常考到的排序算法是快速排序和归并排序，而插入排序、冒泡排序、堆排序、基数排序、桶排序等算法也经常被提及。而排序算法的考察形式往往
也比较常见，就是面试官要求求职者现场写代码，同时也会要求求职者分析各类排序算法的优劣、使用场景、时间复杂度以及空间复杂度等，所以，求职者熟练
掌握各类排序算法思想及特点是非常必要的。     

## 1. 选择排序     
选择排序是一种简单直观的排序算法，它的基本原理是：对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录与第一个记录进行交换；接着对
不包括第一个记录以外的其他记录进行第二轮比较，得到最新小的记录并与第二个记录进行位置交换；重复该过程，直到进行比较的记录只有一个时为止。      
代码实现：      
```python    
import random
mess = (random.randint(1, 1000) for i in range(10))


# 基础版
def select_sort(seq):
    """可以对python中的可迭代对象进行排序"""
    temp_list = list(seq)
    length = len(temp_list)
    for i in range(length-1):
        minimum_index = i
        for j in range(i+1, length):
            if temp_list[j] < temp_list[minimum_index]:
                minimum_index = j
        if i != minimum_index:
            temp_list[i], temp_list[minimum_index] = temp_list[minimum_index], temp_list[i]
    return temp_list


# 进阶版
def select_sort1(seq):
    temp_list = list(seq)
    length = len(temp_list)
    for i in range(length//2):
        minimum_index = i
        maximum_index = -i - 1
        for j in range(i+1, length-i-1):
            if temp_list[j] < temp_list[minimum_index]:
                minimum_index = j
            if temp_list[-j-1] > temp_list[maximum_index]:
                maximum_index = -j - 1
        if temp_list[minimum_index] == temp_list[maximum_index]:
            break
        if maximum_index != -i-1:
            temp_list[maximum_index], temp_list[-i-1] = temp_list[-i-1], temp_list[maximum_index]
            if minimum_index == -i-1 or -i-1 == minimum_index - length:
                minimum_index = maximum_index + length
        if minimum_index != i:
            temp_list[i], temp_list[minimum_index] = temp_list[minimum_index], temp_list[i]
    return temp_list


if __name__ == '__main__':
    print(select_sort1(mess))
```     
选择排序是一种不稳定的排序方法，其中基础版最好、最坏的平均情况下时间复杂度都是O(n<sup>2</sup>)，进阶版最好情况下时间复杂度是O(n)。
