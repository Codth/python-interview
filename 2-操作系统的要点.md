# 操作系统    
## 1. select、poll、epoll    
如果面试官问到了你这个问题，那说明你前面的回答得到了他的满意，这个问题是对你能力的期待。      

**综述：**            
`select`，`poll`，`epoll`都是**IO多路复用**的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），
能够通知程序进行相应的读写操作。但`select`，`poll`，`epoll`本质上都是**同步I/O**，因为他们都需要在读写事件就绪后`自己负责`进行读写，也就是说这个
读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。           

**IO多路复用:**     
`IO多路复用`是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用`适用如下场合`：      
　　（1）当`客户处理多个描述字`时（一般是交互式输入和网络套接口），必须使用I/O复用;          
　　（2）当一个`客户同时处理多个套接口`时，而这种情况是可能的，但很少出现;                
　　（3）如果一个TCP服务器既要处理监`听套接口`，又要`处理已连接套接口`，一般也要用到I/O复用;       
　　（4）如果一个服务器即要`处理TCP，又要处理UDP`，一般要使用I/O复用;       
　　（5）如果一个服务器要处理`多个服务或多个协议`，一般要使用I/O复用;           
　　与`多进程和多线程`技术相比，I/O多路复用技术的最大优势是`系统开销小`，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。      
  
**select的几大缺点：**       
（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大              
（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大          
（3）select支持的文件描述符数量太小了，默认是1024             

**poll：**     
poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用`pollfd结构`而不是select的`fd_set结构`，其他的都差不多。      

**epoll:**       
epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。        

对于`第一个缺点`，epoll的解决方案在epoll_ctl函数中。`每次注册`新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll`保证`了每个fd在整个过程中`只会拷贝一次`。      

对于`第二个缺点`，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为`每个fd`指定一个`回调函数`，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个`就绪链表`）。epoll_wait的工作实际上就是`在这个就绪链表中`查看`有没有`就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果。         

对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在`1GB`内存的机器上`大约是10万左右`，具体数目可以`cat /proc/sys/fs/file-max`察看,一般来说这个数目和系统内存关系很大。             

**总结：**        
（1）select，poll实现需要自己`不断轮询`所有fd集合，直到设备就绪，期间可能要`睡眠`和`唤醒`多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是`设备就绪时`，`调用回调函数`，把就绪fd放入`就绪链表`中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是`select`和`poll`在“`醒着`”的时候要`遍历整个fd`集合，而`epoll`在“`醒着`”的时候`只要判断一下就绪链表`是否为空就行了，这节省了大量的CPU时间。这就是`回调机制`带来的性能提升。              
（2）select，poll`每次调用`都要把fd集合从`用户态`往`内核态`拷贝一次，并且要把current往设备等待队列中挂一次，而`epoll`只要`一次`拷贝，而且把current往等待队列上挂也`只挂一次`（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。            

## 2. 内存管理和虚拟内存    
我们知道，一个进程完成他的功能，需要访问磁盘加载数据到内存然后等待进入cpu运算，因为数据量大小远远大于内存大小。因此提出虚拟内存概念。虚拟内存就是`将程序用到的数据进行划分`，暂时用不到的放到磁盘里，用到的放到内存里，操作系统中总是运行着不止一个进程，各个进程有优先级顺序，所以存在进程调度问题，进程的每次调度都会导致内存和磁盘数据置换，`段式内存管理` `页式内存管理`都是基于虚拟内存概念的具体内存管`理解决方案`。      

## 3. 什么是页式内存管理？    
虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，再也不能直接访问物理内存。每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。顾名思义，既然是虚拟地址，也就是虚的，不是现实存在的地址空间。既然我们在程序和物理地址空间之间增加了虚拟地址，那么就要解决怎么从虚拟地址映射到物理地址，因为程序最终肯定是运行在物理内存中的，主要有分段和分页两种技术。    
`分页机制`就是把内存地址空间分为若干个很小的`固定大小`的页，每一页的大小由内存决定，就`像`Linux中ext文件系统将磁盘分成若干个Block一样，这样做是分别是为了提高内存和磁盘的利用率。     

## 4. x86架构下，页面大小为什么是4K？   
很重要的一个问题就是页面大了，浪费的内存也多了，参考CSDN的文章[为什么linux kernel默认的页面大小是4K，而不是4M或8M？](https://blog.csdn.net/justlinux2010/article/details/8910136)    
