# 操作系统    
## 1. select、poll、epoll    
如果面试官问到了你这个问题，那说明你前面的回答得到了他的满意，这个问题是对你能力的期待。      

**综述：**            
`select`，`poll`，`epoll`都是**IO多路复用**的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），
能够通知程序进行相应的读写操作。但`select`，`poll`，`epoll`本质上都是**同步I/O**，因为他们都需要在读写事件就绪后`自己负责`进行读写，也就是说这个
读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。           

**IO多路复用:**     
`IO多路复用`是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用`适用如下场合`：      
　　（1）当`客户处理多个描述字`时（一般是交互式输入和网络套接口），必须使用I/O复用;          
　　（2）当一个`客户同时处理多个套接口`时，而这种情况是可能的，但很少出现;                
　　（3）如果一个TCP服务器既要处理监`听套接口`，又要`处理已连接套接口`，一般也要用到I/O复用;       
　　（4）如果一个服务器即要`处理TCP，又要处理UDP`，一般要使用I/O复用;       
　　（5）如果一个服务器要处理`多个服务或多个协议`，一般要使用I/O复用;           
　　与`多进程和多线程`技术相比，I/O多路复用技术的最大优势是`系统开销小`，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。      
  
**select的几大缺点：**       
（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大              
（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大          
（3）select支持的文件描述符数量太小了，默认是1024             

**poll：**     
poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用`pollfd结构`而不是select的`fd_set结构`，其他的都差不多。      

**epoll:**       
epoll既然是对select和poll的改进，就应该能避免上述的三个缺点。        

对于`第一个缺点`，epoll的解决方案在epoll_ctl函数中。`每次注册`新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll`保证`了每个fd在整个过程中`只会拷贝一次`。      

对于`第二个缺点`，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为`每个fd`指定一个`回调函数`，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个`就绪链表`）。epoll_wait的工作实际上就是`在这个就绪链表中`查看`有没有`就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果。         

对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在`1GB`内存的机器上`大约是10万左右`，具体数目可以`cat /proc/sys/fs/file-max`察看,一般来说这个数目和系统内存关系很大。             

**总结：**        
（1）select，poll实现需要自己`不断轮询`所有fd集合，直到设备就绪，期间可能要`睡眠`和`唤醒`多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是`设备就绪时`，`调用回调函数`，把就绪fd放入`就绪链表`中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是`select`和`poll`在“`醒着`”的时候要`遍历整个fd`集合，而`epoll`在“`醒着`”的时候`只要判断一下就绪链表`是否为空就行了，这节省了大量的CPU时间。这就是`回调机制`带来的性能提升。              
（2）select，poll`每次调用`都要把fd集合从`用户态`往`内核态`拷贝一次，并且要把current往设备等待队列中挂一次，而`epoll`只要`一次`拷贝，而且把current往等待队列上挂也`只挂一次`（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。            

## 2. 内存管理和虚拟内存    
我们知道，一个进程完成他的功能，需要访问磁盘加载数据到内存然后等待进入cpu运算，因为数据量大小远远大于内存大小。因此提出虚拟内存概念。虚拟内存就是`将程序用到的数据进行划分`，暂时用不到的放到磁盘里，用到的放到内存里，操作系统中总是运行着不止一个进程，各个进程有优先级顺序，所以存在进程调度问题，进程的每次调度都会导致内存和磁盘数据置换，`段式内存管理` `页式内存管理`都是基于虚拟内存概念的具体内存管`理解决方案`。      

## 3. 什么是页式内存管理？    
虚拟内存位于程序和物理内存之间，程序只能看见虚拟内存，再也不能直接访问物理内存。每个程序都有自己独立的进程地址空间，这样就做到了进程隔离。这里的进程地址空间是指虚拟地址。顾名思义，既然是虚拟地址，也就是虚的，不是现实存在的地址空间。既然我们在程序和物理地址空间之间增加了虚拟地址，那么就要解决怎么从虚拟地址映射到物理地址，因为程序最终肯定是运行在物理内存中的，主要有分段和分页两种技术。    
`分页机制`就是把内存地址空间分为若干个很小的`固定大小`的页，每一页的大小由内存决定，就`像`Linux中ext文件系统将磁盘分成若干个Block一样，这样做是分别是为了提高内存和磁盘的利用率。     

## 4. x86架构下，页面大小为什么是4K？   
很重要的一个问题就是页面大了，浪费的内存也多了，参考CSDN的文章[为什么linux kernel默认的页面大小是4K，而不是4M或8M？](https://blog.csdn.net/justlinux2010/article/details/8910136)        

## 5. 常见的调度算法     
**FCFS—先来先服务优先调度算法（FCFS, First Come First Serve）：**         
`先来先服务（FCFS）`调度算法是一种`最简单`的调度算法，该算法既可用于作业调度， 也可用于进程调度。FCFS算法比较`有利于长作业（进程）`，而`不利于短作业（进程）`。由此可知，本算法适合于`CPU繁忙型`作业， 而不利于`I/O繁忙型`的作业（进程）。这里和python的全局解释器进程锁的用法一样，适合I/O密集型。         

**短作业（进程）优先调度算法（SJF, Shortest Job First）：**       
短作业（进程）优先调度算法是指对短作业或短进程优先调度的算法，该算法既可用于作业调度， 也可用于进程调度。但其对长作业不利；不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算出来的。            

**最高优先权调度算法（Priority Scheduling）：**      
为了照顾`紧迫性`作业，使之进入系统后便获得`优先处理`，引入了`最高优先权优先（FPF）调度算法`。 此算法常被用在`批处理系统`中，作为作业调度算法，`也作为`多种操作系统中的`进程调度`，还可以用于`实时系统`中。当其用于作业调度， 将后备队列中若干个优先权最高的作业装入内存。当其用于进程调度时，把处理机分配给`就绪队列中`优先权最高的进程，此时， 又可以进一步把该算法分成以下两种：        
(1)非抢占式优先权算法;      
(2)抢占式优先权调度算法（高性能计算机操作系统）;      

对于最高优先权优先调度算法，其核心在于：它是使用`静态优先权`还是`动态优先权`， 以及`如何确定`进程的优先权。        
`动态优先权：`高响应比优先调度算法为了弥补短作业优先算法的不足，我们引入动态优先权，使作业的`优先等级`随着`等待时间`的增加而以`速率a`提高。 该优先权变化规律可描述为：优先权=（等待时间+要求服务时间）/要求服务时间；即 =（响应时间）/要求服务时间。       

**时间片轮转法（RR, Round Robin）：**     
`时间片轮转法`一般用于`进程调度`，每次调度，把CPU分配`队首`进程，并令其执行一个`时间片`。 当执行的时间片`用完`时，由一个记时器发出一个`时钟中断`请求，该进程被停止，并被送往`就绪队列末尾`；依次循环。        

**多级反馈队列调度算法(multilevel feedback queue scheduling):**      
多级反馈队列调度算法，不必事先知道各种进程所需要执行的时间，它是目前被公认的一种较好的进程调度算法。 其实施过程如下：        
(1) 设置`多个就绪队列`，并为各个队列`赋予不同的优先级`。在`优先权越高`的队列中， 为每个进程所规定的执行`时间片就越小`。      
(2) 当一个新进程进入内存后，首先放入第一队列的末尾，`按FCFS原则排队`等候调度。 如果他能在`一个时间片`中`完成`，便可`撤离`；如果`未完成`，就转入`第二队列的末尾`，再`同样`等待调度…… 如此下去，当一个`长作业`（进程）从`第一队列`依次将到`第n队列`（最后队列）后，便按第n队列时间片轮转运行。        
(3) `仅当`第一队列空闲时，调度程序才调度`第二队列中`的进程运行；`仅当`第1到第（ i-1 ）队列空时， 才会调度`第i队列中`的进程运行，并执行相应的时间片轮转。          
(4) 如果`处理机`正在处理`第i队列中`某进程，又有`新进程`进入`优先权较高`的队列， 则此`新队列`抢占`正在运行`的处理机，并把正在运行的进程放在`第i队列`的队尾。       

**最早截止时间优先调度算法(Earliest DeadlineFirst):**     
`最早截止时间优先EDF算法`是非常著名的`实时调度`算法之一。在每一个`新的就绪状态`，`调度器`都是`从那些已就绪`但`还没有完全处理完毕`的任务中选择`最早截止时间`的任务，并将执行该任务所需的资源分配给它。在有`新任务到来时`，调度器必须`立即计算EDF`，排出`新的定序`，即`正在运行`的任务被剥夺，并且`按照新任务`的截止时间`决定`是否调度`该新任务`。如果新任务的`最后期限早于`被中断的`当前任务`，就`立即处理`新任务。按照EDF算法，被中断任务的处理将在`稍后继续进行`。         

该算法的思想是`从两个任务`中选择`截至时间`最早的任务,把它`暂作`为`当前处理任务`,再`判断`该任务是否在`当前周期内`,`若不在`当前周期内,就让另一任务暂作当前处理任务,若该任务`也不`在当前周期内,就让CPU空跑到`最靠近`的下一个截至时间的开始,若有任务在该周期内,就判断该任务的剩余时间是否小于`当前截至`时间与`当前时间`的差,若小于,则`让该任务运行到结束`.否则,就让该任务运行到`该周期`的截止时间,就`立即抢回`处理器,再判断紧接着的最早截至时间,并把处理器给它,做法同上,如此反复执行.        



## 5. 作业和进程     
 一个`进程`是一个程序对某个数据集的`执行过程`，是`分配资源`的基本单位。`作业`是用户需要计算机完成的`某项任务`，是要求计算机所做`工作`的`集合`。一个作业的完成要经过`作业提交`、`作业收容`、`作业执行`和`作业完成`4个阶段。而`进程`是对`已提交完毕`的程序所执行过程的描述，是`资源分配`的`基本单位`。其主要区别如下:        
（1）`作业`是用户向计算机提交任务的`任务实体`。在用户向计算机提交作业后，系统将它放入`外存中`的`作业等待队列中`等待执行。而`进程`则是完成用户任务的`执行实体`，是向系统申请分配资源的基本单位。任一进程，只要它被创建，总有相应的部分存在于`内存中`。       
（2）`一个`作业可由`多个`进程组成，且必须`至少`由`一个进程`组成，反过来则不成立。     
（3）作业的概念主要用在`批处理系统`中，像UNIX这样的`分时系统`中就`没有作业`的概念。而`进程`的概念则用在几乎`所有`的`多道程序系统`中。      

`操作系统`只认识`进程`，只对`进程`进行`调度`，`作业`其实和`操作系统`没有关系。 执行一个可执行程序，就会生成一个进程（程序里面`exec`别的可执行程序或者`fork`进程除外），所以执行`date`，`who`，`cut`这些都会各自生成一个进程。          
`作业`是`shell`里面的一个概念，我们的`所有操作`都是`提交给shell`，然后`通过shell`进行`解释`后再执行，管道连起来的`命令`以及自己写的`shell程序`都相当于一个`批处理`。          
一个`批处理`就是一个`作业`。管道连接在一起的`命令`也是一个作业。一个`作业`就是我们提交给shell的`一项任务`,这个任务可能包含多个命令或者可执行程序，再`复杂一些`的任务可能需要我们自己`进行shell编程`，写一个shell程序，里面含有分支，循环等，然后在命令行执行这个shell程序（比如：test.sh）,这也是一个作业。这个作业具体执行的时候，可能会生成一个`进程`（比如ls），或者多个进程（比如：`who | cut -c 1-8 | sort | uniq -c`）。        
一个`作业`是我们提交给shell的`一项任务`或者`批处理`，和操作系统无关。 `进程`是具体执行的一个`可执行程序`，是操作系统`调度`的对象。        

