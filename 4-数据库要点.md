# 数据库   

## 1. 彻底理解数据库事物   

**一：事物的定义：**   
事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，
事务通常就是指数据库事务。   
通俗的讲：事务，由若干条语句组成的，指的是要做的一系列操作。        

**二：事物的目的：**       
1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。        
2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。         

**解释：**当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中
，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被**回滚**，回到事务执行前的状态（**要么全执行，要么全都不执行**）;同时，
该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。      

但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，
甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。
为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护**事务日志**以追踪事务中所有影响数据库数据的操作。         

**三：事物的特性：**      
并非任意的对数据库的操作序列都是数据库事务，事务应该具有4个属性：**原子性**、**一致性**、**隔离性**、**持久性**，这四个属性通常称为ACID特性。     
**原子性（Atomicity）**：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。     
**一致性（Consistency）**：事务应确保数据库的状态从一个一致状态转变为另一个一致状态，一致状态的含义是数据库中的数据应满足完整性约束。      
**隔离性（Isolation）**：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。     
**持久性（Durability）**：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。          

**四：举例：**    
用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：     
1、从A账号中把余额读出来（500）；    
2、对A账号做减法操作（500-100）；    
3、把结果写回A账号中（400）；   
4、从B账号中把余额读出来（500）；    
5、对B账号做加法操作（500+100）；    
6、把结果写回B账号中（600）。       

原子性：
保证1-6所有过程要么都执行，要么都不执行；一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作；
假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。      

一致性：     
在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元；
也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。   

隔离性：    
在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化；     
如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。    

持久性：    
一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）！       

原子性和一致性：
一致性与原子性是密切相关的,原子性的破坏可能导致数据库的不一致，数据的一致性问题并不都和原子性有关；
比如刚刚的例子，在第五步的时候，对B账户做加法时只加了50元。那么该过程可以符合原子性，但是数据的一致性就出现了问题。     
因此，事务的原子性与一致性缺一不可！      

**五：MySQL隔离级别：**    
隔离性不好，事务的操作就会互相影响，带来不同严重程度的后果;     
首先看看隔离性不好，带来哪些问题：       
1. 更新丢失Lost Update      
事务A和B，更新同一个数据，它们都读取了初始值100，A要减10，B要加100，A减去10后更新为90，B加
100更新为200，A的更新丢失了，**就像从来没有减过10一样**。      
2. 脏读       
事务A和B，事务B读取到了事务**A未提交**的数据（这个数据可能是一个中间值，也可能事务A后来回滚事
务）;事务A是否最后提交并不关心，只要读取到了这个被修改的数据就是脏读。      
3. 不可重复读Unrepeatable read       
事务A在**事务执行中**相同查询语句，得到了不同的结果，**不能保证**同一条查询语句重复读**相同的结果**就是不可
以重复读。       
例如，事务A查询了一次后，事务B修改了数据，事务A又查询了一次，发现数据不一致了。     
注意，脏读讲的是可以读到相同的数据的，但是读取的是一个未提交的数据，而不是提交的最终结果。       
4. 幻读Phantom read         
事务A中同一个查询要进行多次，事务B插入数据，导致A返回不同的结果集，如同幻觉，就是幻读；
数据集有记录增加了，可以看做是增加了记录的不可重复读。       

有了上述问题，数据库就必须要解决，提出了隔离级别。
隔离级别由低到高，如下：      
**READ UNCOMMITTED** 读取到未提交的数据     
**READ COMMITTED** 读已经提交的数据，ORACLE默认隔离级别     
**REPEATABLE READ** 可以重复读，MySQL的 默认隔离级别      
**SERIALIZABLE** 可串行化，事务间完全隔离，事务不能并发，只能串行执行      
隔离级别越高，串行化越高，数据库执行效率低；隔离级别越低，并行度越高，性能越高；隔离级别越高，当前事务处理的中间结果对其它事务不可见程度越高。       

**其中：**    
**SERIALIZABLE**，串行了，解决所有问题，但是**效率极低**；  

**REPEATABLE READ**，事务A中同一条查询语句返回同样的结果，就是可以重复读数据了。例如语句为(select * 
from user)。实现可重复读的办法有：    
1、对select的数据**加锁**，不允许其它事务删除、修改的操作；   
2、第一次select的时候，对最后一次确切提交的事务的结果做**快照**；    
解决了不可以重复读，但是**有可能出现幻读**；因为另一个事务可以增删数据。   

**READ COMMITTED**，在事务中，每次select可以读取到别的事务**刚提交成功**的新的数据，因为读到的是提交后的
数据，解决了脏读，但是**不能解决** 不可重复读 和 幻读 的问题。因为其他事务前后修改了数据或增删了数据。     

**READ UNCOMMITTED**，能读取到别的事务还没有提交的数据，完全没有隔离性可言，出现了**脏读**，当前其他问题
都可能出现。     

**六：事物语法：**    
`START TRANSACTION`或`BEGIN`开始一个事务，`START TRANSACTION`是标准SQL的语法;
使用`COMMIT`提交事务后，变更成为永久变更。   

`ROLLBACK`可以在提交事务之前，回滚变更，事务中的操作就如同没有发生过一样（原子性）;        

`SET AUTOCOMMIT`语句可以禁用或启用默认的`autocommit`模式，用于当前连接。`SET AUTOCOMMIT = 0`禁用自
动提交事务;如果开启自动提交，如果有一个修改表的语句执行后，会立即把更新存储到磁盘。     


参考博客：[彻底明白事物](https://blog.csdn.net/qq_38727847/article/details/103244950)     


