# 数据库   

## 1. 彻底理解数据库事物   

**一：事物的定义：**   
事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，
事务通常就是指数据库事务。   
通俗的讲：事务，由若干条语句组成的，指的是要做的一系列操作。        

**二：事物的目的：**       
1、为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。        
2、当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。         

**解释：**当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中
，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被**回滚**，回到事务执行前的状态（**要么全执行，要么全都不执行**）;同时，
该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。      

但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，
甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。
为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护**事务日志**以追踪事务中所有影响数据库数据的操作。         

**三：事物的特性：**      
并非任意的对数据库的操作序列都是数据库事务，事务应该具有4个属性：**原子性**、**一致性**、**隔离性**、**持久性**，这四个属性通常称为ACID特性。     
**原子性（Atomicity）**：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。     
**一致性（Consistency）**：事务应确保数据库的状态从一个一致状态转变为另一个一致状态，一致状态的含义是数据库中的数据应满足完整性约束。      
**隔离性（Isolation）**：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。     
**持久性（Durability）**：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。          

**四：举例：**    
用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：     
1、从A账号中把余额读出来（500）；    
2、对A账号做减法操作（500-100）；    
3、把结果写回A账号中（400）；   
4、从B账号中把余额读出来（500）；    
5、对B账号做加法操作（500+100）；    
6、把结果写回B账号中（600）。       

原子性：
保证1-6所有过程要么都执行，要么都不执行；一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作；
假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。      

一致性：     
在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元；
也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。   

隔离性：    
在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化；     
如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。    

持久性：    
一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）！       

原子性和一致性：
一致性与原子性是密切相关的,原子性的破坏可能导致数据库的不一致，数据的一致性问题并不都和原子性有关；
比如刚刚的例子，在第五步的时候，对B账户做加法时只加了50元。那么该过程可以符合原子性，但是数据的一致性就出现了问题。     
因此，事务的原子性与一致性缺一不可！      

**五：MySQL隔离级别：**    
隔离性不好，事务的操作就会互相影响，带来不同严重程度的后果;     
首先看看隔离性不好，带来哪些问题：       
1. 更新丢失Lost Update      
事务A和B，更新同一个数据，它们都读取了初始值100，A要减10，B要加100，A减去10后更新为90，B加
100更新为200，A的更新丢失了，**就像从来没有减过10一样**。      
2. 脏读       
事务A和B，事务B读取到了事务**A未提交**的数据（这个数据可能是一个中间值，也可能事务A后来回滚事
务）;事务A是否最后提交并不关心，只要读取到了这个被修改的数据就是脏读。      
3. 不可重复读Unrepeatable read       
事务A在**事务执行中**相同查询语句，得到了不同的结果，**不能保证**同一条查询语句重复读**相同的结果**就是不可
以重复读。       
例如，事务A查询了一次后，事务B修改了数据，事务A又查询了一次，发现数据不一致了。     
注意，脏读讲的是可以读到相同的数据的，但是读取的是一个未提交的数据，而不是提交的最终结果。       
4. 幻读Phantom read         
事务A中同一个查询要进行多次，事务B插入数据，导致A返回不同的结果集，如同幻觉，就是幻读；
数据集有记录增加了，可以看做是增加了记录的不可重复读。       

有了上述问题，数据库就必须要解决，提出了隔离级别。
隔离级别由低到高，如下：      
**READ UNCOMMITTED** 读取到未提交的数据     
**READ COMMITTED** 读已经提交的数据，ORACLE默认隔离级别     
**REPEATABLE READ** 可以重复读，MySQL的 默认隔离级别      
**SERIALIZABLE** 可串行化，事务间完全隔离，事务不能并发，只能串行执行      
隔离级别越高，串行化越高，数据库执行效率低；隔离级别越低，并行度越高，性能越高；隔离级别越高，当前事务处理的中间结果对其它事务不可见程度越高。       

**其中：**    
**SERIALIZABLE**，串行了，解决所有问题，但是**效率极低**；  

**REPEATABLE READ**，事务A中同一条查询语句返回同样的结果，就是可以重复读数据了。例如语句为(select * 
from user)。实现可重复读的办法有：    
1、对select的数据**加锁**，不允许其它事务删除、修改的操作；   
2、第一次select的时候，对最后一次确切提交的事务的结果做**快照**；    
解决了不可以重复读，但是**有可能出现幻读**；因为另一个事务可以增删数据。   

**READ COMMITTED**，在事务中，每次select可以读取到别的事务**刚提交成功**的新的数据，因为读到的是提交后的
数据，解决了脏读，但是**不能解决** 不可重复读 和 幻读 的问题。因为其他事务前后修改了数据或增删了数据。     

**READ UNCOMMITTED**，能读取到别的事务还没有提交的数据，完全没有隔离性可言，出现了**脏读**，当前其他问题
都可能出现。     

**六：事物语法：**    
`START TRANSACTION`或`BEGIN`开始一个事务，`START TRANSACTION`是标准SQL的语法;
使用`COMMIT`提交事务后，变更成为永久变更。   

`ROLLBACK`可以在提交事务之前，回滚变更，事务中的操作就如同没有发生过一样（原子性）;        

`SET AUTOCOMMIT`语句可以禁用或启用默认的`autocommit`模式，用于当前连接。`SET AUTOCOMMIT = 0`禁用自
动提交事务;如果开启自动提交，如果有一个修改表的语句执行后，会立即把更新存储到磁盘。     


参考博客：[彻底明白事物](https://blog.csdn.net/qq_38727847/article/details/103244950)     

## 2. 数据库和数据仓库的区别   
本质上来说没有区别，都是存放数据的地方；但是数据库关注数据的持久化、数据的关系，为业务系统提供支持，事务支持；
数据仓库存储数据的是为了分析或者发掘而设计的表结构，可以存储海量数据。      
数据库存储在线交易数据**OLTP**（联机事务处理OLTP，On-line Transaction Processing）；数据仓库存储历史数据
用于分析OLAP（联机分析处理OLAP，On-Line Analytical Processing）。       
数据库支持在线业务，需要频繁增删改查；数据仓库一般囤积历史数据支持用于分析的SQL，一般不建议删改。       

## 3. 数据库的安装    
关系型数据库以安装MariaDB为例（centos7环境）：    
```    
[root@centos7 ~]# yum list | grep mariadb

mariadb-libs.x86_64                1:5.5.60-1.el7_5           @anaconda
mariadb.x86_64                      1:5.5.60-1.el7_5          base
mariadb-bench.x86_64                1:5.5.60-1.el7_5          base
mariadb-devel.i686                  1:5.5.60-1.el7_5          base
mariadb-devel.x86_64                1:5.5.60-1.el7_5          base
mariadb-embedded.i686               1:5.5.60-1.el7_5          base
mariadb-embedded.x86_64             1:5.5.60-1.el7_5          base
mariadb-embedded-devel.i686         1:5.5.60-1.el7_5          base
mariadb-embedded-devel.x86_64       1:5.5.60-1.el7_5          base
mariadb-libs.i686                   1:5.5.60-1.el7_5          base
mariadb-server.x86_64               1:5.5.60-1.el7_5          base
mariadb-test.x86_64                 1:5.5.60-1.el7_5          base

安装mariadb服务，会自动安装mariadb
[root@centos7 ~]# yum install mariadb-server

[root@centos7 ~]# systemctl start mariadb.service

[root@centos7 ~]# ss -tanl
LISTEN     0     50       *:3306        *:*

开机启动
[root@centos7 ~]# systemctl enable mariadb.service

为了安全设置Mysql服务
[root@centos7 ~]# mysql_secure_installation

数据库密码登陆
[root@centos7 ~]# mysql -u root -p
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
+--------------------+
3 rows in set (0.00 sec)

创建并授权用户
mysql> grant all on *.* to 'root'@'%' identified by 'daneil11';
mysql> flush privileges;
```     

## 4. SQL语句概述     
**SQL**是结构化查询语言**Structured Query Language**,1987年被ISO组织标准化。       
所有主流的关系型数据库都支持SQL，NoSQL也有很大一部分支持SQL。     
**SQL语句分类：**    
**DDL数据定义**语言，负责数据库定义、数据库对象定义，由`CREATE`、`ALTER`与`DROP`三种语句组
成；     
**DML数据操作**语言，负责对数据库对象的操作，`CRUD`增删改查；     
**DCL数据控制**语言，负责数据库权限访问控制，由 `GRANT` 和 `REVOKE` 两个指令组成；     
**TCL事务控制**语言，负责处理`ACID`事务，支持`commit`、`rollback`指令；     

**语言规范：**
`SQL`语句`大小写不敏感`   
一般建议，`SQL`的关键字、函数等大写     
`SQL`语句末尾应该使用分号结束    

**注释**     
多行注释  `/*注释内容*/`    
单行注释  `-- 注释内容`    
`MySQL` 注释可以使用`#`      
使用空格或缩进来提高可读性     

**命名规范**    
必须以字母开头    
可以使用`数字、#、$和_`     
不可使用关键字       

**DCL**     
`GRANT`授权、`REVOKE`撤销；      
```    
GRANT ALL ON employees.* TO 'root' IDENTIFIED by 'daneil11';
REVOKE ALL ON *.* FROM 'duanming'
```     
`*`为通配符，指代任意库或者任意表; `*.*`所有库的所有表； `employees.*`表示employees库下所有的表；`%` 为通配符，它是SQL语句的通配符，匹配任意长度字符串；         

**DDL**    
1. 创建数据库，所有数据按照数据模型组织在数据库中;    
```    
CREATE DATABASE IF NOT EXISTS test CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;
CREATE DATABASE IF NOT EXISTS test CHARACTER SET utf8;
```    
`CHARACTER SET`指定字符集; `utf8mb4`是`utf8`的扩展，支持4字节`utf8mb4`，需要`MySQL5.5.3+`; `COLLATE`指定字符集的校对规则，用来做字符串的比较的;例如a、A谁大？      

2. 删除数据库;     
```   
DROP DATABASE IF EXISTS test;   
```     

3. 删除用户；    
```    
DROP USER duanming;   
```    

**创建表**    
表也称为关系，分为行和列，MySQL是行存数据库。数据是一行行存的，列必须固定多少列。     
行Row，也称为记录Record，元组。     
列Column，也称为字段Field、属性。     
字段的取值范围叫做 域Domain。例如gender字段的取值就是M或者F两个值。      
![table](https://github.com/duanmingpy/python-interview/blob/master/images/table.png)    
1. 选择创建到的数据库    
```   
use table_name;
```    
2. 创建表     
```    
CREATE TABLE `employees` (
    `emp_no` int(11) NOT NULL,
    `birth_date` date NOT NULL,
    `first_name` varchar(14) NOT NULL,
    `last_name` varchar(16) NOT NULL,
    `gender` enum('M', 'F') NOT NULL,
    `hire_date` date NOT NULL,
    PRIMARY KEY (`emp_no`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```   
其中，反引号标注的名称，会被认为是非关键字，使用反引号避免冲突。      

**DESC**     
查看列信息：     
{DESCRIBE | DESC} tbl_name [col_name | wild]    
```
DESC employees;
DESC employees '%name';
```    

## 5. 什么是主键、外键、关系等概念   

**关系**  
关系是什么？      
在关系数据库中，关系就是二维表，由行和列组成。

二维表中的术语？       
行`Row`，也称为记录`Record`，元组；    
列`Column`，也称为字段`Field`、属性；    
字段的取值范围叫做 域Domain。例如gender字段的取值就是M或者F两个值；    
维数：关系的维数指关系中属性的个数；     
基数：元组的个数。     
注意在关系中，属性的顺序并不重要；理论上，元组顺序也不重要，但是由于元组顺序与存储相关，会
影响查询效率。      

**候选键**     
关系中，能唯一标识一条元组的属性或属性集合，称为候选键。    
候选键，表中一列或者多列组成唯一的key，通过这一个或者多个列能唯一的标识一条记录。    
表中可能有多个候选键。      

**PRIMARY KEY主键**     
从候选键中选择出主键。     
主键的列不能包含空值`null`。主键往往设置为`整型、长整型`，可以为自增`AUTO_INCREMENT`字段。    
表中可以没有主键，但是，一般表设计中，往往都会有主键，以避免记录重复。InnoDB的表`要求`使用主键。     

**Foreign KEY外键**      
严格来说，当一个关系中的某个属性或属性集合与另一个关系（也可以是自身）的**候选键**匹配时，就称
作这个属性或属性集合是外键。      

**索引Index**    
可以看做是一本字典的目录，为了快速检索用的；空间换时间，显著提高查询效率。     
可以对一列或者多列字段设定索引。      
`主键索引`，主键会自动建立主键索引，主键本身就是为了快速定位唯一记录的。   
`唯一索引`，表中的索引列组成的索引必须唯一，但可以为空，非空值必须唯一。     
`普通索引`，没有唯一性的要求，就是建了一个字典的目录而已。     
联合索引，多个字段组合创建索引，使用条件查询时，先匹配左边字段。     

全文索引，MyISAM使用，对Char、Varchar、TEXT类型使用。      
空间索引，SPATIAL，基本不用。       

在`MySQL`中，`InnoDB`和`MyISAM`的索引数据结构可以使用`Hash`或`BTree`，`innodb`默认是`BTree`。     
`Hash`时间复杂度是`O(1)`，但是只能进行精确匹配，也就是`Hash`值的匹配，比如范围匹配就没办法了，
`hash`值无序所以无法知道原有记录的顺序。`Hash`问题较多。      

`BTree`索引，以B+树为存储结构。      
虽然，索引可以提高查询所读，但是却影响增删改的效率，因为需要索引更新或重构。频繁出现在
`where`子句中的列可以考虑使用索引。要避免把性别这种字段设索引。      
